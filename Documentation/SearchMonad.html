<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SearchMonad</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_SearchMonad.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">SearchMonad</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Menthors: prof. dr. Andrej Bauer and asist. dr. Matija Pretnar
</p><p>Authors: Petra Poklukar, Jure Kukovec
</p><p>Contains the monad for arbitrary searchable spaces.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">newtype</span>  <a href="#t:S">S</a> a = <a href="#v:S">S</a> {<ul class="subs"><li><a href="#v:find">find</a> :: (a -&gt; Bool) -&gt; a</li></ul>}</li><li class="src short"><a href="#v:exists_mon">exists_mon</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Bool</li><li class="src short"><a href="#v:forall_mon">forall_mon</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Bool</li><li class="src short"><a href="#v:singleton">singleton</a> ::  a -&gt; <a href="SearchMonad.html#t:S">S</a> a</li><li class="src short"><a href="#v:search">search</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Maybe a</li><li class="src short"><a href="#v:union">union</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> a</li><li class="src short"><a href="#v:doubleton">doubleton</a> ::  a -&gt; a -&gt; <a href="SearchMonad.html#t:S">S</a> a</li><li class="src short"><a href="#v:image">image</a> ::  (a -&gt; b) -&gt; <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> b</li><li class="src short"><a href="#v:bigUnion">bigUnion</a> ::  <a href="SearchMonad.html#t:S">S</a> (<a href="SearchMonad.html#t:S">S</a> a) -&gt; <a href="SearchMonad.html#t:S">S</a> a</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:S" class="def">S</a> a </p><div class="doc"><p>S over some type a (e.g. Cantor) is a record with exactly one field, which represents its find function (e.g. find_i defined in Find_X for Cantor spaces).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:S" class="def">S</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:find" class="def">find</a> :: (a -&gt; Bool) -&gt; a</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:S" class="caption collapser" onclick="toggleSection('i:S')">Instances</p><div id="section.i:S" class="show"><table><tr><td class="src">Monad <a href="SearchMonad.html#t:S">S</a></td><td class="doc"><p>S will be a monad representing searchable sets, a subset of the power set of a given type (e.g. Cantor).
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:exists_mon" class="def">exists_mon</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Bool</p><div class="doc"><p>Existential and universal quantifiers defined for searchable sets.
</p></div></div><div class="top"><p class="src"><a name="v:forall_mon" class="def">forall_mon</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Bool</p><div class="doc"><p>Existential and universal quantifiers defined for searchable sets.
</p></div></div><div class="top"><p class="src"><a name="v:singleton" class="def">singleton</a> ::  a -&gt; <a href="SearchMonad.html#t:S">S</a> a</p><div class="doc"><p>Cannonical mapping of an element into a searchable set. Any predicate tested on a singelton {x} must always return x since it must return something even if the predicate is not satisfied.
</p></div></div><div class="top"><p class="src"><a name="v:search" class="def">search</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; (a -&gt; Bool) -&gt; Maybe a</p><div class="doc"><p>Modified <code><a href="SearchMonad.html#v:find">find</a></code> which returns Nothing if the predicate is not satisfied for any element and a Just value otherwise.
</p></div></div><div class="top"><p class="src"><a name="v:union" class="def">union</a> ::  <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> a</p><div class="doc"><p>Set-theoretical definition of <code><a href="SearchMonad.html#v:union">union</a></code> where <code><a href="SearchMonad.html#v:bigUnion">bigUnion</a></code> creates the union of a familiy of sets.
</p></div></div><div class="top"><p class="src"><a name="v:doubleton" class="def">doubleton</a> ::  a -&gt; a -&gt; <a href="SearchMonad.html#t:S">S</a> a</p><div class="doc"><p>Searching a doubleton {x, y} for an element that satisfies a given predicate p yields x if p(x) holds and must yield some element of {x,y} otherwise, therefore it returns y if p(x) does not hold.
</p></div></div><div class="top"><p class="src"><a name="v:image" class="def">image</a> ::  (a -&gt; b) -&gt; <a href="SearchMonad.html#t:S">S</a> a -&gt; <a href="SearchMonad.html#t:S">S</a> b</p><div class="doc"><p>Given that a subset of a is searchable, the f-image is also searchable. One can find an element in the f-image satisfying a given predicate q by searching the original set for elements satisfying a predicate testing whether q holds for f(x) where x is of type a.
</p></div></div><div class="top"><p class="src"><a name="v:bigUnion" class="def">bigUnion</a> ::  <a href="SearchMonad.html#t:S">S</a> (<a href="SearchMonad.html#t:S">S</a> a) -&gt; <a href="SearchMonad.html#t:S">S</a> a</p><div class="doc"><p>Since none of the functions defined above are restricted to the Cantor set we implement the search over an abstract union in two stages. First, using an auxiliary predicate, we find a member of a given family of sets, that contains some element satisfying the original predicate (note that this gives us no answer as to which element it is at this point). Then, this set can again be searched for the particular element.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>